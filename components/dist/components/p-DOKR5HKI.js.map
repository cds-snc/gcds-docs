{"version":3,"names":["I18N","en","valueMissing","typeMismatch","email","url","patternMismatch","tooLong","tooShort","rangeUnderflow","rangeOverflow","stepMismatch","badInput","fr","inheritAttributes","el","shadowElement","attributes","attributeObject","i","length","attr","name","includes","value","forEach","hasAttribute","getAttribute","removeAttribute","assignLanguage","lang","closestLangAttribute","_a","closestElement","selector","document","window","closest","getRootNode","host","observerConfig","attributeOldValue","attributeFilter","emitEvent","e","customEvent","event","emit","defaultPrevented","preventDefault","logError","errorArr","optionalAttrsArrToRemove","engMsg","frMsg","errors","optionalAttr","splice","indexOf","console","error","handleErrors","propertyName","property","external","trim","push","isValid","requiredProps","intersection","filter","x","isValidDate","dateString","forceFormat","fullregex","compactregex","format","test","formattedDate","isValidDay","date","year","month","day","split","map","Number","thirtyOneDays","thirtyDays","isLeapYear","y","handleValidationResult","element","validationResult","label","errorEv","validEv","valid","errorMessage","reason","message","formatHTMLErrorMessage","type","replace","maxlength","characterCount","minlength","min","max","Math","floor","step","validateRadioCheckboxGroup","elements","oneValid","some","r","validity","customError"],"sources":["src/utils/i18n/i18n.js","src/utils/utils.ts"],"sourcesContent":["const I18N = {\n  en: {\n    valueMissing: 'Enter information to continue.',\n    typeMismatch: {\n      email:\n        'Enter a valid email address to continue. Use a standard format. Example: name@address.ca.',\n      url: 'Enter a URL in the specified format to continue.',\n    },\n    patternMismatch: 'Use the specified format to continue.',\n    tooLong:\n      \"Enter {max} characters or less to continue. You've entered {current} characters.\",\n    tooShort:\n      \"Enter at least {min} characters to continue. You've entered {current} characters.\",\n    rangeUnderflow: \"Enter a number that's {min} or more to continue.\",\n    rangeOverflow: \"Enter a number that's {max} or less to continue.\",\n    stepMismatch:\n      'Enter a number from the specified options to continue. The closest numbers to what you entered are {lower} and {upper}. ',\n    badInput: 'Enter a number to continue.',\n  },\n  fr: {\n    valueMissing: 'Saisissez des renseignements pour continuer.',\n    typeMismatch: {\n      email:\n        'Saisissez votre adresse courriel pour continuer. Utilisez un format standard. Exemple: nom@adresse.ca.',\n      url: 'Entrez une adresse Web en utilisant le format spécifié pour continuer.',\n    },\n    patternMismatch: 'Utilisez le format spécifié pour continuer.',\n    tooLong:\n      'Entrez {max} caractères ou moins pour continuer. Vous en avez présentement {current}.',\n    tooShort:\n      'Entrez au moins {min} caractères pour continuer. Vous en avez présentement {current}.',\n    rangeUnderflow:\n      'Entrez un nombre plus grand ou égal à {min} pour continuer.',\n    rangeOverflow:\n      'Entrez un nombre plus petit ou égal à {max} pour continuer.',\n    stepMismatch:\n      'Entrez un nombre parmi les options spécifiées pour continuer. Les nombres les plus proches de votre entrée sont {lower} et {upper}.',\n    badInput: 'Entrez un nombre pour continuer.',\n  },\n};\n\nexport default I18N;\n","import { EventEmitter } from '@stencil/core';\nimport { ValidatorReturn } from '../validators';\nimport I18N from './i18n/i18n.js';\n\nexport function format(label: string): string {\n  return label ? ` ${label}` : 'Fallback Button Label';\n}\n\nexport const inheritAttributes = (\n  el: HTMLElement,\n  shadowElement: HTMLElement,\n  attributes: string[] = [],\n) => {\n  const attributeObject = {};\n  const attributesToRemove = [];\n\n  // Check for any aria attributes\n  for (let i = 0; i < el.attributes.length; i++) {\n    const attr = el.attributes[i];\n    if (attr.name.includes('aria-')) {\n      attributeObject[attr.name] = attr.value;\n      attributesToRemove.push(attr.name);\n    }\n  }\n\n  // Check for attributes defined by component\n  attributes.forEach(attr => {\n    if (\n      el.hasAttribute(attr) ||\n      (shadowElement && shadowElement.hasAttribute(attr))\n    ) {\n      const value = el.getAttribute(attr) || shadowElement.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] =\n          el.getAttribute(attr) || shadowElement.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n\n  return attributeObject;\n};\n\nexport const assignLanguage = (el: HTMLElement) => {\n  let lang = '';\n  if (!el.getAttribute('lang')) {\n    const closestLangAttribute = closestElement('[lang]', el)?.getAttribute(\n      'lang',\n    );\n    if (closestLangAttribute == 'en' || !closestLangAttribute) {\n      lang = 'en';\n    } else {\n      lang = 'fr';\n    }\n  } else if (el.getAttribute('lang') == 'en') {\n    lang = 'en';\n  } else {\n    lang = 'fr';\n  }\n\n  return lang;\n};\n\n// Allows use of closest() function across shadow boundaries\nexport const closestElement = (selector, el) => {\n  if (el) {\n    return (\n      (el &&\n        el != document &&\n        typeof window != 'undefined' &&\n        el != window &&\n        el.closest(selector)) ||\n      closestElement(selector, el.getRootNode().host)\n    );\n  }\n\n  return null;\n};\n\nexport const observerConfig = {\n  attributes: true,\n  attributeOldValue: true,\n  attributeFilter: ['lang'],\n};\n\n// For validation - check if element has a checked checkbox/radio sibling\nexport const elementGroupCheck = name => {\n  let hasCheck = false;\n  const element = document.querySelectorAll<HTMLFormElement>(\n    `input[name=${name}]`,\n  );\n  for (let i = 0; i < element.length; i++) {\n    if (element[i].checked) {\n      hasCheck = true;\n    }\n  }\n  return !hasCheck;\n};\n\n// Emit event with logic to cancel HTML events\n// Returns false if event has been prevented\nexport const emitEvent = (\n  e: Event,\n  customEvent: EventEmitter,\n  value?: unknown,\n) => {\n  const event = customEvent.emit(value);\n\n  // Was the custom or native event interrupted\n  if (event.defaultPrevented || e.defaultPrevented) {\n    // Stop native HTML event in shadow-dom\n    e.preventDefault();\n    return false;\n  }\n\n  return true;\n};\n\n/* Log validation error for required properties in components\n * @param name - name of the component i.e. <gcds-*>\n * @param errorArr - array of attributes with errors\n * @param optionalAttrsArrToRemove - array of optional attributes with errors to be removed from this error message\n */\nexport const logError = (\n  name: string,\n  errorArr: string[],\n  optionalAttrsArrToRemove?: string[],\n) => {\n  const engMsg = 'Render error, please check required properties.';\n  const frMsg = 'Erreur de rendu, veuillez vérifier les propriétés requises.';\n  const errors = [...errorArr];\n\n  // remove any potential optional attributes from errors array\n  if (optionalAttrsArrToRemove && optionalAttrsArrToRemove.length > 0) {\n    for (const optionalAttr of optionalAttrsArrToRemove) {\n      if (errors.includes(optionalAttr)) {\n        errors.splice(errors.indexOf(optionalAttr), 1);\n      }\n    }\n  }\n\n  console.error(\n    `${name}: ${engMsg} (${errors}) | ${name}: ${frMsg} (${errors})`,\n  );\n};\n\n/* Log validation error for required properties in components\n * @param errors - array of attributes with errors\n * @param propertyName - name of the property being checked\n * @param property - value of the property being checked\n * @param external - boolean value for an external check on property value\n * @returns modified array of errors\n */\nexport const handleErrors = (\n  errors: string[],\n  propertyName: string,\n  property: string | boolean | object,\n  external: boolean = false,\n) => {\n  if (\n    (property && typeof property === 'string' && property.trim() === '') ||\n    !property ||\n    property === '' ||\n    external\n  ) {\n    if (!errors.includes(propertyName)) {\n      errors.push(propertyName);\n    }\n  } else if (errors.includes(propertyName)) {\n    errors.splice(errors.indexOf(propertyName), 1);\n  }\n\n  return errors;\n};\n\n/* Compare errors array to required props array\n * @param errors - array of attributes with errors\n * @param requiredProps - array of required properties to check against\n * @returns boolean if no matching errors\n */\nexport const isValid = (errors: string[], requiredProps: string[]) => {\n  const intersection = errors.filter(x => requiredProps.includes(x));\n\n  return intersection.length > 0 ? false : true;\n};\n\n/* Check for valid date\n * @param dateString - the date to check\n */\nexport const isValidDate = (\n  dateString: string,\n  forceFormat?: 'full' | 'compact',\n) => {\n  // Define regex pattern to match YYYY-MM-DD format\n  const fullregex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  const compactregex = /^\\d{4}-\\d{2}$/;\n  let format = '';\n\n  // Check if the format matches the regex\n  if (fullregex.test(dateString)) {\n    format = 'full';\n  } else if (compactregex.test(dateString)) {\n    format = 'compact';\n  } else {\n    return false;\n  }\n\n  if (forceFormat && format != forceFormat) {\n    return false;\n  }\n\n  // Parse the date string into a Date object\n  const formattedDate = `${dateString}${format === 'compact' ? '-15' : ''}`;\n\n  return isValidDay(formattedDate);\n};\n\nexport function isValidDay(date) {\n  const [year, month, day] = date.split('-').map(Number);\n\n  const thirtyOneDays = [1, 3, 5, 7, 8, 10, 12];\n  const thirtyDays = [4, 6, 9, 11];\n\n  if (month < 1 || month > 12) {\n    return false;\n  } else if (thirtyDays.includes(month) && (day < 1 || day > 30)) {\n    return false;\n  } else if (thirtyOneDays.includes(month) && (day < 1 || day > 31)) {\n    return false;\n  } else if (!isLeapYear(year) && month === 2 && (day < 1 || day > 28)) {\n    return false;\n  } else if (isLeapYear(year) && month === 2 && (day < 1 || day > 29)) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction isLeapYear(y: number) {\n  return !(y & 3 || (!(y % 25) && y & 15));\n}\n\n/* Handle the returned validation result by assigning properties and emitting events\n * @param element - the gcds form element that is being validated\n * @param validationResult - the object returned from the validator\n * @param label - the label of the form element\n * @param errorEv - the gcdsError event emitter\n * @param validEv - the gcdsValid event emitter\n * @param lang - the current language\n * @param errors - default errors object to pass back for more complicated validation scenarios\n */\nexport function handleValidationResult(\n  element:\n    | HTMLGcdsInputElement\n    | HTMLGcdsDateInputElement\n    | HTMLGcdsRadiosElement\n    | HTMLGcdsCheckboxesElement\n    | HTMLGcdsFileUploaderElement\n    | HTMLGcdsSelectElement\n    | HTMLGcdsTextareaElement,\n  validationResult: ValidatorReturn,\n  label: string,\n  errorEv: EventEmitter,\n  validEv: EventEmitter,\n  lang: string,\n  errors?: object,\n) {\n  if (!validationResult.valid) {\n    element.errorMessage = validationResult.reason[lang];\n    errorEv.emit({\n      message: `${label} - ${validationResult.reason[lang]}`,\n    });\n\n    if (validationResult.errors) {\n      return validationResult.errors;\n    }\n  } else {\n    element.errorMessage = '';\n    validEv.emit();\n  }\n\n  return errors;\n}\n\n/**\n * Format HTML error message based off assigned attributes\n * This lets us assign custom error messages\n *\n * @param error - the HTML validation error type\n * @param lang - the current language\n * @param el - the gcds form element that is being validated\n */\nexport function formatHTMLErrorMessage(error, lang, el) {\n  switch (error) {\n    case 'valueMissing':\n      return I18N[lang][error];\n    case 'typeMismatch':\n      if (el.type === 'url' || el.type === 'email') {\n        return I18N[lang][error][el.type];\n      } else {\n        return I18N[lang][error];\n      }\n    case 'tooLong':\n      return I18N[lang][error]\n        .replace('{max}', el.maxlength || el.characterCount)\n        .replace('{current}', el.value.length);\n    case 'tooShort':\n      return I18N[lang][error]\n        .replace('{min}', el.minlength)\n        .replace('{current}', el.value.length);\n    case 'rangeUnderflow':\n      return I18N[lang][error].replace('{min}', el.min);\n    case 'rangeOverflow':\n      return I18N[lang][error].replace('{max}', el.max);\n    case 'stepMismatch':\n      return I18N[lang][error]\n        .replace(\n          '{lower}',\n          Math.floor(Number(el.value) / Number(el.step)) * Number(el.step),\n        )\n        .replace(\n          '{upper}',\n          Math.floor(Number(el.value) / Number(el.step)) * Number(el.step) +\n            Number(el.step),\n        );\n    case 'badInput':\n    case 'patternMismatch':\n    default:\n      return I18N[lang][error];\n  }\n}\n\n/**\n * Compare validity of radio buttons/checkboxes in a group\n * @param elements - array of HTMLInputElements in the group\n * @returns validity state object\n */\nexport function validateRadioCheckboxGroup(\n  elements: HTMLInputElement[],\n): ValidityState {\n  if (elements && elements.length > 0) {\n    const oneValid = elements.some(r => r.validity?.valid);\n\n    const validity: ValidityState = {\n      valueMissing: !oneValid,\n      typeMismatch: false,\n      patternMismatch: false,\n      tooLong: false,\n      tooShort: false,\n      rangeUnderflow: false,\n      rangeOverflow: false,\n      stepMismatch: false,\n      badInput: false,\n      customError: false,\n      valid: oneValid,\n    };\n\n    return validity;\n  }\n}\n"],"mappings":"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","ignoreList":[]}