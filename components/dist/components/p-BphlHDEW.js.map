{"version":3,"names":["inheritAttributes","el","shadowElement","attributes","attributeObject","i","length","attr","name","includes","value","forEach","hasAttribute","getAttribute","removeAttribute","assignLanguage","lang","closestLangAttribute","_a","closestElement","selector","document","window","closest","getRootNode","host","observerConfig","attributeOldValue","attributeFilter","emitEvent","e","customEvent","event","emit","defaultPrevented","preventDefault","logError","errorArr","optionalAttrsArrToRemove","engMsg","frMsg","errors","optionalAttr","splice","indexOf","console","error","handleErrors","propertyName","property","external","trim","push","isValid","requiredProps","intersection","filter","x","isValidDate","dateString","forceFormat","fullregex","compactregex","format","test","formattedDate","year","month","day","split","map","Number","thirtyOneDays","thirtyDays","isLeapYear","y","handleValidationResult","element","validationResult","label","errorEv","validEv","valid","errorMessage","reason","message"],"sources":["src/utils/utils.ts"],"sourcesContent":["import { EventEmitter } from '@stencil/core';\nimport { ValidatorReturn } from '../validators';\n\nexport function format(label: string): string {\n  return label ? ` ${label}` : 'Fallback Button Label';\n}\n\nexport const inheritAttributes = (\n  el: HTMLElement,\n  shadowElement: HTMLElement,\n  attributes: string[] = [],\n) => {\n  const attributeObject = {};\n  const attributesToRemove = [];\n\n  // Check for any aria attributes\n  for (let i = 0; i < el.attributes.length; i++) {\n    const attr = el.attributes[i];\n    if (attr.name.includes('aria-')) {\n      attributeObject[attr.name] = attr.value;\n      attributesToRemove.push(attr.name);\n    }\n  }\n\n  // Check for attributes defined by component\n  attributes.forEach(attr => {\n    if (\n      el.hasAttribute(attr) ||\n      (shadowElement && shadowElement.hasAttribute(attr))\n    ) {\n      const value = el.getAttribute(attr) || shadowElement.getAttribute(attr);\n      if (value !== null) {\n        attributeObject[attr] =\n          el.getAttribute(attr) || shadowElement.getAttribute(attr);\n      }\n      el.removeAttribute(attr);\n    }\n  });\n\n  return attributeObject;\n};\n\nexport const assignLanguage = (el: HTMLElement) => {\n  let lang = '';\n  if (!el.getAttribute('lang')) {\n    const closestLangAttribute = closestElement('[lang]', el)?.getAttribute(\n      'lang',\n    );\n    if (closestLangAttribute == 'en' || !closestLangAttribute) {\n      lang = 'en';\n    } else {\n      lang = 'fr';\n    }\n  } else if (el.getAttribute('lang') == 'en') {\n    lang = 'en';\n  } else {\n    lang = 'fr';\n  }\n\n  return lang;\n};\n\n// Allows use of closest() function across shadow boundaries\nexport const closestElement = (selector, el) => {\n  if (el) {\n    return (\n      (el &&\n        el != document &&\n        typeof window != 'undefined' &&\n        el != window &&\n        el.closest(selector)) ||\n      closestElement(selector, el.getRootNode().host)\n    );\n  }\n\n  return null;\n};\n\nexport const observerConfig = {\n  attributes: true,\n  attributeOldValue: true,\n  attributeFilter: ['lang'],\n};\n\n// For validation - check if element has a checked checkbox/radio sibling\nexport const elementGroupCheck = name => {\n  let hasCheck = false;\n  const element = document.querySelectorAll<HTMLFormElement>(\n    `input[name=${name}]`,\n  );\n  for (let i = 0; i < element.length; i++) {\n    if (element[i].checked) {\n      hasCheck = true;\n    }\n  }\n  return !hasCheck;\n};\n\n// Emit event with logic to cancel HTML events\n// Returns false if event has been prevented\nexport const emitEvent = (\n  e: Event,\n  customEvent: EventEmitter,\n  value?: unknown,\n) => {\n  const event = customEvent.emit(value);\n\n  // Was the custom or native event interrupted\n  if (event.defaultPrevented || e.defaultPrevented) {\n    // Stop native HTML event in shadow-dom\n    e.preventDefault();\n    return false;\n  }\n\n  return true;\n};\n\n/* Log validation error for required properties in components\n * @param name - name of the component i.e. <gcds-*>\n * @param errorArr - array of attributes with errors\n * @param optionalAttrsArrToRemove - array of optional attributes with errors to be removed from this error message\n */\nexport const logError = (\n  name: string,\n  errorArr: string[],\n  optionalAttrsArrToRemove?: string[],\n) => {\n  const engMsg = 'Render error, please check required properties.';\n  const frMsg = 'Erreur de rendu, veuillez vérifier les propriétés requises.';\n  const errors = [...errorArr];\n\n  // remove any potential optional attributes from errors array\n  if (optionalAttrsArrToRemove && optionalAttrsArrToRemove.length > 0) {\n    for (const optionalAttr of optionalAttrsArrToRemove) {\n      if (errors.includes(optionalAttr)) {\n        errors.splice(errors.indexOf(optionalAttr), 1);\n      }\n    }\n  }\n\n  console.error(\n    `${name}: ${engMsg} (${errors}) | ${name}: ${frMsg} (${errors})`,\n  );\n};\n\n/* Log validation error for required properties in components\n * @param errors - array of attributes with errors\n * @param propertyName - name of the property being checked\n * @param property - value of the property being checked\n * @param external - boolean value for an external check on property value\n * @returns modified array of errors\n */\nexport const handleErrors = (\n  errors: string[],\n  propertyName: string,\n  property: string | boolean | object,\n  external: boolean = false,\n) => {\n  if (\n    (property && typeof property === 'string' && property.trim() === '') ||\n    !property ||\n    property === '' ||\n    external\n  ) {\n    if (!errors.includes(propertyName)) {\n      errors.push(propertyName);\n    }\n  } else if (errors.includes(propertyName)) {\n    errors.splice(errors.indexOf(propertyName), 1);\n  }\n\n  return errors;\n};\n\n/* Compare errors array to required props array\n * @param errors - array of attributes with errors\n * @param requiredProps - array of required properties to check against\n * @returns boolean if no matching errors\n */\nexport const isValid = (errors: string[], requiredProps: string[]) => {\n  const intersection = errors.filter(x => requiredProps.includes(x));\n\n  return intersection.length > 0 ? false : true;\n};\n\n/* Check for valid date\n * @param dateString - the date to check\n */\nexport const isValidDate = (\n  dateString: string,\n  forceFormat?: 'full' | 'compact',\n) => {\n  // Define regex pattern to match YYYY-MM-DD format\n  const fullregex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  const compactregex = /^\\d{4}-\\d{2}$/;\n  let format = '';\n\n  // Check if the format matches the regex\n  if (fullregex.test(dateString)) {\n    format = 'full';\n  } else if (compactregex.test(dateString)) {\n    format = 'compact';\n  } else {\n    return false;\n  }\n\n  if (forceFormat && format != forceFormat) {\n    return false;\n  }\n\n  // Parse the date string into a Date object\n  const formattedDate = `${dateString}${format === 'compact' ? '-15' : ''}`;\n\n  // Check if the date is valid\n  const [year, month, day] = formattedDate.split('-').map(Number);\n\n  const thirtyOneDays = [1, 3, 5, 7, 8, 10, 12];\n  const thirtyDays = [4, 6, 9, 11];\n\n  if (month < 1 || month > 12) {\n    return false;\n  } else if (thirtyDays.includes(month) && (day < 1 || day > 30)) {\n    return false;\n  } else if (thirtyOneDays.includes(month) && (day < 1 || day > 31)) {\n    return false;\n  } else if (!isLeapYear(year) && month === 2 && (day < 1 || day > 28)) {\n    return false;\n  } else if (isLeapYear(year) && month === 2 && (day < 1 || day > 29)) {\n    return false;\n  }\n\n  return true;\n};\n\nfunction isLeapYear(y: number) {\n  return !(y & 3 || (!(y % 25) && y & 15));\n}\n\n/* Handle the returned validation result by assigning properties and emitting events\n * @param element - the gcds form element that is being validated\n * @param validationResult - the object returned from the validator\n * @param label - the label of the form element\n * @param errorEv - the gcdsError event emitter\n * @param validEv - the gcdsValid event emitter\n * @param lang - the current language\n * @param errors - default errors object to pass back for more complicated validation scenarios\n */\nexport function handleValidationResult(\n  element:\n    | HTMLGcdsInputElement\n    | HTMLGcdsDateInputElement\n    | HTMLGcdsRadiosElement\n    | HTMLGcdsCheckboxesElement\n    | HTMLGcdsFileUploaderElement\n    | HTMLGcdsSelectElement\n    | HTMLGcdsTextareaElement,\n  validationResult: ValidatorReturn,\n  label: string,\n  errorEv: EventEmitter,\n  validEv: EventEmitter,\n  lang: string,\n  errors?: object,\n) {\n  if (!validationResult.valid) {\n    element.errorMessage = validationResult.reason[lang];\n    errorEv.emit({\n      message: `${label} - ${validationResult.reason[lang]}`,\n    });\n\n    if (validationResult.errors) {\n      return validationResult.errors;\n    }\n  } else {\n    element.errorMessage = '';\n    validEv.emit();\n  }\n\n  return errors;\n}\n"],"mappings":"AAOO,MAAMA,EAAoB,CAC/BC,EACAC,EACAC,EAAuB,MAEvB,MAAMC,EAAkB,GAIxB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,EAAGE,WAAWG,OAAQD,IAAK,CAC7C,MAAME,EAAON,EAAGE,WAAWE,GAC3B,GAAIE,EAAKC,KAAKC,SAAS,SAAU,CAC/BL,EAAgBG,EAAKC,MAAQD,EAAKG,K,EAMtCP,EAAWQ,SAAQJ,IACjB,GACEN,EAAGW,aAAaL,IACfL,GAAiBA,EAAcU,aAAaL,GAC7C,CACA,MAAMG,EAAQT,EAAGY,aAAaN,IAASL,EAAcW,aAAaN,GAClE,GAAIG,IAAU,KAAM,CAClBN,EAAgBG,GACdN,EAAGY,aAAaN,IAASL,EAAcW,aAAaN,E,CAExDN,EAAGa,gBAAgBP,E,KAIvB,OAAOH,CAAe,EAGX,MAAAW,EAAkBd,I,MAC7B,IAAIe,EAAO,GACX,IAAKf,EAAGY,aAAa,QAAS,CAC5B,MAAMI,GAAuBC,EAAAC,EAAe,SAAUlB,MAAK,MAAAiB,SAAA,SAAAA,EAAAL,aACzD,QAEF,GAAII,GAAwB,OAASA,EAAsB,CACzDD,EAAO,I,KACF,CACLA,EAAO,I,OAEJ,GAAIf,EAAGY,aAAa,SAAW,KAAM,CAC1CG,EAAO,I,KACF,CACLA,EAAO,I,CAGT,OAAOA,CAAI,E,MAIAG,EAAiB,CAACC,EAAUnB,KACvC,GAAIA,EAAI,CACN,OACGA,GACCA,GAAMoB,iBACCC,QAAU,aACjBrB,GAAMqB,QACNrB,EAAGsB,QAAQH,IACbD,EAAeC,EAAUnB,EAAGuB,cAAcC,K,CAI9C,OAAO,IAAI,EAGA,MAAAC,EAAiB,CAC5BvB,WAAY,KACZwB,kBAAmB,KACnBC,gBAAiB,CAAC,SAmBP,MAAAC,EAAY,CACvBC,EACAC,EACArB,KAEA,MAAMsB,EAAQD,EAAYE,KAAKvB,GAG/B,GAAIsB,EAAME,kBAAoBJ,EAAEI,iBAAkB,CAEhDJ,EAAEK,iBACF,OAAO,K,CAGT,OAAO,IAAI,EAQA,MAAAC,EAAW,CACtB5B,EACA6B,EACAC,KAEA,MAAMC,EAAS,kDACf,MAAMC,EAAQ,8DACd,MAAMC,EAAS,IAAIJ,GAGnB,GAAIC,GAA4BA,EAAyBhC,OAAS,EAAG,CACnE,IAAK,MAAMoC,KAAgBJ,EAA0B,CACnD,GAAIG,EAAOhC,SAASiC,GAAe,CACjCD,EAAOE,OAAOF,EAAOG,QAAQF,GAAe,E,GAKlDG,QAAQC,MACN,GAAGtC,MAAS+B,MAAWE,QAAajC,MAASgC,MAAUC,KACxD,EAUI,MAAMM,EAAe,CAC1BN,EACAO,EACAC,EACAC,EAAoB,SAEpB,GACGD,UAAmBA,IAAa,UAAYA,EAASE,SAAW,KAChEF,GACDA,IAAa,IACbC,EACA,CACA,IAAKT,EAAOhC,SAASuC,GAAe,CAClCP,EAAOW,KAAKJ,E,OAET,GAAIP,EAAOhC,SAASuC,GAAe,CACxCP,EAAOE,OAAOF,EAAOG,QAAQI,GAAe,E,CAG9C,OAAOP,CAAM,E,MAQFY,EAAU,CAACZ,EAAkBa,KACxC,MAAMC,EAAed,EAAOe,QAAOC,GAAKH,EAAc7C,SAASgD,KAE/D,OAAOF,EAAajD,OAAS,EAAI,MAAQ,IAAI,E,MAMlCoD,EAAc,CACzBC,EACAC,KAGA,MAAMC,EAAY,sBAClB,MAAMC,EAAe,gBACrB,IAAIC,EAAS,GAGb,GAAIF,EAAUG,KAAKL,GAAa,CAC9BI,EAAS,M,MACJ,GAAID,EAAaE,KAAKL,GAAa,CACxCI,EAAS,S,KACJ,CACL,OAAO,K,CAGT,GAAIH,GAAeG,GAAUH,EAAa,CACxC,OAAO,K,CAIT,MAAMK,EAAgB,GAAGN,IAAaI,IAAW,UAAY,MAAQ,KAGrE,MAAOG,EAAMC,EAAOC,GAAOH,EAAcI,MAAM,KAAKC,IAAIC,QAExD,MAAMC,EAAgB,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAAI,IAC1C,MAAMC,EAAa,CAAC,EAAG,EAAG,EAAG,IAE7B,GAAIN,EAAQ,GAAKA,EAAQ,GAAI,CAC3B,OAAO,K,MACF,GAAIM,EAAWhE,SAAS0D,KAAWC,EAAM,GAAKA,EAAM,IAAK,CAC9D,OAAO,K,MACF,GAAII,EAAc/D,SAAS0D,KAAWC,EAAM,GAAKA,EAAM,IAAK,CACjE,OAAO,K,MACF,IAAKM,EAAWR,IAASC,IAAU,IAAMC,EAAM,GAAKA,EAAM,IAAK,CACpE,OAAO,K,MACF,GAAIM,EAAWR,IAASC,IAAU,IAAMC,EAAM,GAAKA,EAAM,IAAK,CACnE,OAAO,K,CAGT,OAAO,IAAI,EAGb,SAASM,EAAWC,GAClB,QAASA,EAAI,KAAQA,EAAI,KAAOA,EAAI,GACtC,CAWgB,SAAAC,EACdC,EAQAC,EACAC,EACAC,EACAC,EACAjE,EACAyB,GAEA,IAAKqC,EAAiBI,MAAO,CAC3BL,EAAQM,aAAeL,EAAiBM,OAAOpE,GAC/CgE,EAAQ/C,KAAK,CACXoD,QAAS,GAAGN,OAAWD,EAAiBM,OAAOpE,OAGjD,GAAI8D,EAAiBrC,OAAQ,CAC3B,OAAOqC,EAAiBrC,M,MAErB,CACLoC,EAAQM,aAAe,GACvBF,EAAQhD,M,CAGV,OAAOQ,CACT,Q","ignoreList":[]}