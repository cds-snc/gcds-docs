{"version":3,"names":["isCheckboxObject","obj","validKeys","objKeys","Object","keys","hasValidTypes","id","label","value","undefined","hint","checked","hasOnlyValidKeys","every","key","includes","validateOptionsArray","optionsArr","invalidOptionsArr","length","some","checkbox","cleanUpValues","element","availableValues","forEach","push","filter","item","renderCheckbox","emitEvent","handleInput","name","disabled","hasError","errorMessage","gcdsFocus","gcdsInput","gcdsChange","gcdsClick","gcdsBlur","required","isGroup","lang","checkboxTitle","form","hideLabel","onBlurValidate","attrsInput","title","labelAttrs","hintID","h","class","assign","type","onBlur","emit","onFocus","onChange","e","onInput","onClick","stopImmediatePropagation","ref","el","shadowElement","stopPropagation","messageId","I18N","en","fr","gcdsCheckboxesCss","GcdsCheckboxes","__stencil_proxyCustomElement","HTMLElement","constructor","this","_validator","defaultValidator","hideLegend","validateOn","inheritedAttributes","errors","validate","customEvent","isInputEvent","target","options","JSON","parse","map","check","internals","setFormValue","toString","updateValidity","validateName","handleErrors","validateLegend","legend","validateOptions","invalidOptions","assignOptionsArray","validateDisabledCheckbox","validateValue","newValue","Array","isArray","logError","validateErrorMessage","validateValidator","getValidator","validator","validity","validateHasError","handleValidationResult","gcdsError","gcdsValid","formdataListener","data","formData","indexOf","set","append","submitListener","closest","preventDefault","formResetCallback","initialState","formStateRestoreCallback","state","split","checkValidity","getValidationMessage","validationMessage","_a","validateRadioCheckboxGroup","valueMissing","setValidity","watchLang","oldValue","validateRequiredProps","isValid","componentWillLoad","assignLanguage","valid","requiredValidator","componentDidUpdate","componentDidLoad","autofocus","requestAnimationFrame","focus","trim","optionsCheck","render","fieldsetAttrs","tabindex","Host","tag","i18n","Fragment"],"sources":["src/components/gcds-checkboxes/checkbox.tsx","src/components/gcds-checkboxes/i18n/i18n.js","src/components/gcds-checkboxes/gcds-checkboxes.css?tag=gcds-checkboxes&encapsulation=shadow","src/components/gcds-checkboxes/gcds-checkboxes.tsx"],"sourcesContent":["import { h } from '@stencil/core';\n\nexport type CheckboxObject = {\n  id: string;\n  label: string;\n  value?: string;\n  hint?: string;\n  checked?: boolean | string;\n};\n\n/* Check if passed object matches required CheckboxObject type\n * @param obj - object to check\n */\nexport function isCheckboxObject(obj: CheckboxObject) {\n  if (typeof obj !== 'object' || obj === null) return false;\n\n  const validKeys = ['id', 'label', 'value', 'hint', 'checked', 'required'];\n  const objKeys = Object.keys(obj);\n\n  // Check if all properties match the expected type\n  const hasValidTypes =\n    typeof obj.id === 'string' &&\n    typeof obj.label === 'string' &&\n    (obj.value === undefined || typeof obj.value === 'string') &&\n    (obj.hint === undefined || typeof obj.hint === 'string') &&\n    (obj.checked === undefined || typeof obj.checked === 'boolean');\n\n  // Ensure no extra properties exist\n  const hasOnlyValidKeys = objKeys.every(key => validKeys.includes(key));\n\n  return hasValidTypes && hasOnlyValidKeys;\n}\n\n/* Loop through the optionsArr and check if each option/checkbox is formatted correctly\n * @param optionsArr - array of objects to be checked\n */\nexport function validateOptionsArray(optionsArr) {\n  let invalidOptionsArr = false;\n\n  if (optionsArr && optionsArr.length >= 1) {\n    invalidOptionsArr = optionsArr.some(\n      checkbox => !isCheckboxObject(checkbox),\n    );\n  } else if (optionsArr && optionsArr.length == 0) {\n    invalidOptionsArr = true;\n  }\n\n  return invalidOptionsArr;\n}\n\n/* Loop through manually assigned value to check if it is available in rendered checkboxes\n * @param optionsArr - array of checkbox objects to compare to\n * @param element - the checkboxes element\n */\nexport function cleanUpValues(optionsArr, element) {\n  const availableValues = [];\n  optionsArr.forEach(checkbox => {\n    availableValues.push(checkbox.value ? checkbox.value : 'on');\n\n    if (\n      (checkbox.checked == 'true' || checkbox.checked === true) &&\n      !(element.value as Array<string>).includes(checkbox.value || 'on')\n    ) {\n      element.value = [\n        ...(element.value as Array<string>),\n        checkbox.value ? checkbox.value : 'on',\n      ];\n    }\n  });\n\n  // Remove any values that are not available in the inputs\n  (element.value as Array<string>)\n    .filter(value => !availableValues.includes(value))\n    .forEach(value => {\n      element.value = (element.value as Array<string>).filter(\n        item => item !== value,\n      );\n    });\n}\n\nexport const renderCheckbox = (checkbox, element, emitEvent, handleInput) => {\n  const {\n    name,\n    disabled,\n    hasError,\n    errorMessage,\n    gcdsFocus,\n    gcdsInput,\n    gcdsChange,\n    gcdsClick,\n    gcdsBlur,\n    required,\n    hint,\n    isGroup,\n    lang,\n    value,\n    checkboxTitle,\n    form,\n    hideLabel,\n    onBlurValidate,\n  } = element;\n\n  const attrsInput = {\n    name: name,\n    id: checkbox.id,\n    disabled: disabled,\n    required: required,\n    value: checkbox.value,\n    title: checkboxTitle,\n    form: form,\n  };\n\n  const labelAttrs = {\n    'label': checkbox.label,\n    'label-for': checkbox.id,\n    lang,\n  };\n\n  if (!isGroup && required) {\n    labelAttrs['required'] = required;\n    attrsInput['required'] = required;\n  }\n\n  if (!isGroup && hideLabel) {\n    labelAttrs['hide-label'] = hideLabel;\n  }\n\n  if (checkbox.hint) {\n    const hintID = `hint-${checkbox.id}`;\n    attrsInput['aria-describedby'] = `${hintID}${attrsInput['aria-describedby'] ? `${attrsInput['aria-describedby']}` : ''\n      }`;\n  }\n\n  if (value.includes(checkbox.value)) {\n    attrsInput['checked'] = true;\n  }\n\n  if (hasError) {\n    attrsInput['aria-invalid'] = 'true';\n    attrsInput['aria-description'] = errorMessage;\n  }\n\n  return (\n    <div\n      class={`gcds-checkbox ${disabled ? 'gcds-checkbox--disabled' : ''} ${hasError ? 'gcds-checkbox--error' : ''\n        }`}\n    >\n      <input\n        type=\"checkbox\"\n        {...attrsInput}\n        onBlur={isGroup ? () => gcdsBlur.emit() : onBlurValidate}\n        onFocus={() => gcdsFocus.emit()}\n        onChange={e => handleInput(e, gcdsChange)}\n        onInput={e => handleInput(e, gcdsInput)}\n        onClick={e =>\n          !disabled ? emitEvent(e, gcdsClick) : e.stopImmediatePropagation()\n        }\n        ref={(el) => (element.shadowElement = [...(element.shadowElement || []), el])}\n      />\n\n      <gcds-label\n        {...labelAttrs}\n        onClick={e => e.stopPropagation()}\n      ></gcds-label>\n\n      {checkbox.hint || (!isGroup && hint) ? (\n        <gcds-hint hint-id={checkbox.id}>\n          {!isGroup && hint ? hint : checkbox.hint}\n        </gcds-hint>\n      ) : null}\n\n      {!isGroup && errorMessage ? (\n        <gcds-error-message messageId={checkbox.id}>\n          {errorMessage}\n        </gcds-error-message>\n      ) : null}\n    </div>\n  );\n};\n","const I18N = {\n  en: {\n    required: ' (required)',\n  },\n  fr: {\n    required: ' (obligatoire)',\n  },\n};\n\nexport default I18N;\n","@layer reset, default, disabled, error, focus;\n\n@layer reset {\n  :host {\n    display: block;\n\n    .gcds-checkboxes__fieldset {\n      border: 0;\n      padding: 0;\n      min-inline-size: auto;\n\n      legend {\n        padding: 0;\n      }\n    }\n\n    .gcds-checkbox {\n      padding: 0;\n\n      gcds-label {\n        display: block;\n        & > label {\n          &:before,\n          &:after {\n            cursor: pointer;\n            content: '';\n            box-sizing: border-box;\n            position: absolute;\n          }\n        }\n      }\n    }\n  }\n}\n\n@layer default {\n  :host {\n    .gcds-checkboxes__fieldset {\n      margin: var(--gcds-checkbox-fieldset-margin);\n\n      .gcds-checkboxes__legend {\n        font: var(--gcds-checkbox-legend-font-desktop);\n        margin: var(--gcds-checkbox-legend-margin);\n\n        .legend__required {\n          font: var(--gcds-checkbox-legend-required-font-desktop);\n        }\n\n        @media only screen and (width < 48em) {\n          font: var(--gcds-checkbox-legend-font-mobile);\n\n          .legend__required {\n            font: var(--gcds-checkbox-legend-required-font-mobile);\n          }\n        }\n\n        &:not(:has(+ gcds-hint)) {\n          margin: var(--gcds-checkbox-legend-hint-margin);\n        }\n      }\n    }\n\n    .gcds-checkbox {\n      position: relative;\n      max-width: var(--gcds-checkbox-max-width);\n      min-height: calc(\n        var(--gcds-checkbox-input-height-and-width) -\n          var(--gcds-checkbox-padding)\n      );\n      font: var(--gcds-checkbox-font);\n      color: var(--gcds-checkbox-default-text);\n      margin: var(--gcds-checkbox-margin) !important;\n      padding: var(--gcds-checkbox-padding) 0 0;\n      transition: color ease-in-out 0.15s;\n\n      :is(gcds-label, gcds-hint, gcds-error-message) {\n        padding: var(--gcds-checkbox-label-padding) !important;\n      }\n\n      gcds-hint::part(hint) {\n        margin: 0;\n      }\n\n      input,\n      gcds-label:before,\n      gcds-label:after {\n        position: absolute;\n      }\n\n      input,\n      gcds-label > label:before {\n        top: 0;\n        left: 0;\n        width: var(--gcds-checkbox-input-height-and-width);\n        height: var(--gcds-checkbox-input-height-and-width);\n      }\n\n      input {\n        opacity: 0;\n      }\n\n      gcds-label > label {\n        width: fit-content;\n        --gcds-label-font-desktop: var(--gcds-checkbox-label-font-desktop);\n        --gcds-label-font-mobile: var(--gcds-checkbox-label-font-mobile);\n\n        &:before {\n          background-color: var(--gcds-checkbox-default-background);\n          border: var(--gcds-checkbox-input-border-width) solid currentcolor;\n          border-radius: var(--gcds-checkbox-input-border-radius);\n          transition:\n            border-color ease-in-out 0.15s,\n            box-shadow ease-in-out 0.15s,\n            outline ease-in-out 0.15s;\n        }\n\n        &:after {\n          border: var(--gcds-checkbox-check-border-width) solid currentcolor;\n          border-inline-start: 0 !important;\n          border-block-start: 0 !important;\n          height: var(--gcds-checkbox-check-height);\n          width: var(--gcds-checkbox-check-width);\n          left: var(--gcds-checkbox-check-left);\n          opacity: 0;\n          top: var(--gcds-checkbox-check-top);\n          transform: rotate(40deg);\n        }\n      }\n\n      input:checked + gcds-label > label:after {\n        opacity: 1;\n      }\n    }\n  }\n}\n\n@layer disabled {\n  :host .gcds-checkbox.gcds-checkbox--disabled {\n    color: var(--gcds-checkbox-disabled-text);\n\n    gcds-label > label {\n      --gcds-label-text: currentColor;\n      cursor: not-allowed;\n\n      &:before,\n      &:after {\n        cursor: not-allowed;\n      }\n\n      &:before {\n        border-color: currentcolor;\n        background-color: var(--gcds-checkbox-disabled-background);\n      }\n    }\n\n    gcds-hint {\n      --gcds-hint-text: currentColor;\n    }\n  }\n}\n\n@layer error {\n  :host\n    .gcds-checkbox.gcds-checkbox--error:not(:focus-within)\n    gcds-label\n    > label {\n    &:before {\n      border-color: var(--gcds-checkbox-danger-border);\n    }\n\n    &:after {\n      color: var(--gcds-checkbox-danger-border);\n    }\n  }\n}\n\n@layer focus {\n  :host .gcds-checkbox:focus-within {\n    input:focus + gcds-label > label:before {\n      color: var(--gcds-checkbox-focus-color);\n      outline: var(--gcds-checkbox-focus-outline-width) solid currentcolor;\n      outline-offset: var(--gcds-checkbox-input-border-width);\n      box-shadow: var(--gcds-checkbox-focus-box-shadow);\n      background: var(--gcds-checkbox-focus-background);\n    }\n\n    input:focus + gcds-label > label:after {\n      color: var(--gcds-checkbox-focus-color);\n    }\n  }\n}\n","import {\n  Component,\n  Element,\n  Event,\n  EventEmitter,\n  Fragment,\n  Listen,\n  Method,\n  State,\n  Prop,\n  Watch,\n  Host,\n  h,\n  AttachInternals,\n} from '@stencil/core';\nimport {\n  assignLanguage,\n  emitEvent,\n  logError,\n  handleErrors,\n  isValid,\n  handleValidationResult,\n  validateRadioCheckboxGroup\n} from '../../utils/utils';\nimport {\n  Validator,\n  defaultValidator,\n  ValidatorEntry,\n  getValidator,\n  requiredValidator,\n} from '../../validators';\nimport {\n  CheckboxObject,\n  cleanUpValues,\n  renderCheckbox,\n  validateOptionsArray,\n} from './checkbox';\nimport i18n from './i18n/i18n';\n\n/**\n * Checkboxes provide a set of options for multiple responses.\n */\n@Component({\n  tag: 'gcds-checkboxes',\n  styleUrl: 'gcds-checkboxes.css',\n  shadow: { delegatesFocus: true },\n  formAssociated: true,\n})\nexport class GcdsCheckboxes {\n  @Element() el: HTMLGcdsCheckboxesElement;\n\n  @AttachInternals()\n  internals: ElementInternals;\n\n  private initialState?: string | string[];\n\n  private shadowElement?: HTMLInputElement[];\n\n  private optionsArr;\n  private isGroup = false;\n\n  // @ts-ignore - Used by renderCheckbox() to set title on error\n  private checkboxTitle = '';\n\n  _validator: Validator<string | string[]> = defaultValidator;\n\n  /**\n   * Props\n   */\n\n  /**\n   * Name attribute for a checkboxes element.\n   */\n  @Prop({ reflect: true, mutable: false }) name!: string;\n\n  @Watch('name')\n  validateName() {\n    this.errors = handleErrors(this.errors, 'name', this.name);\n  }\n\n  /**\n   * Set the legend for fieldset form group.\n   */\n  @Prop({ reflect: true, mutable: false }) legend: string;\n\n  @Watch('legend')\n  validateLegend() {\n    if (this.isGroup) {\n      this.errors = handleErrors(this.errors, 'legend', this.legend);\n    }\n  }\n\n  /**\n   * Options to render checkboxes buttons\n   */\n  @Prop({ mutable: true }) options!: string | Array<CheckboxObject>;\n\n  @Watch('options')\n  validateOptions() {\n    let invalidOptions = false;\n\n    // Assign optionsArr based on valid options property\n    invalidOptions = this.assignOptionsArray();\n\n    // Check if each checkbox object is formatted correctly\n    if (this.optionsArr && !invalidOptions) {\n      invalidOptions = validateOptionsArray(this.optionsArr);\n\n      // Assign if isGroup logic more than one checkbox object\n      if (this.optionsArr && this.optionsArr.length > 1) {\n        this.isGroup = true;\n      }\n    }\n\n    // Log error if invalidOptions\n    this.errors = handleErrors(\n      this.errors,\n      'options',\n      this.optionsArr,\n      invalidOptions,\n    );\n  }\n\n  /**\n   * Specifies if the checkboxes are required or not.\n   */\n  @Prop({ reflect: true, mutable: false }) required: boolean;\n\n  /**\n   * Specifies if the checkboxes are disabled or not.\n   */\n  @Prop({ reflect: true, mutable: true }) disabled: boolean;\n\n  @Watch('disabled')\n  validateDisabledCheckbox() {\n    if (this.required) {\n      this.disabled = false;\n    }\n  }\n\n  /**\n * If true, the checkobox will be focused on component render\n */\n  @Prop({ reflect: true }) autofocus: boolean;\n\n  /**\n   * The ID of the form that the checkboxes belong to.\n   */\n  @Prop({ reflect: true }) form?: string;\n\n  /**\n   * For single checkbox, specifies if the label is hidden or not.\n   */\n  @Prop() hideLabel?: boolean = false;\n\n  /**\n   * For checkbox groups, specifies if the legend is hidden or not.\n   */\n  @Prop() hideLegend?: boolean = false;\n\n  /**\n   * Value for checkboxes component.\n   */\n  @Prop({ reflect: true, mutable: true }) value: string | Array<string> = [];\n\n  @Watch('value')\n  validateValue(newValue) {\n    // Convert string to array\n    if (!Array.isArray(newValue)) {\n      try {\n        this.value = JSON.parse(newValue);\n      } catch (e) {\n        logError('gcds-checkboxes', ['Invalid array for value']);\n        this.value = [];\n      }\n    } else if (this.optionsArr) {\n      // Remove any manually set values that do not match available inputs\n      cleanUpValues(this.optionsArr, this.el);\n\n      // Set form value only when a value is assigned\n      if ((this.value as string[]).length > 0) {\n        this.internals.setFormValue(this.value.toString());\n      }\n    }\n\n    this.updateValidity();\n  }\n\n  /**\n   * Set this to display an error message for invalid <gcds-checkboxes>\n   */\n  @Prop({ reflect: true, mutable: true }) errorMessage: string;\n\n  @Watch('errorMessage')\n  validateErrorMessage() {\n    if (this.disabled) {\n      this.errorMessage = '';\n    } else {\n      this.hasError = this.errorMessage ? !this.hasError : false;\n    }\n  }\n\n  /**\n   * Hint displayed below the label.\n   */\n  @Prop({ reflect: true, mutable: true }) hint: string;\n\n  /**\n   * Array of validators\n   */\n  @Prop({ mutable: true }) validator: Array<\n    string | ValidatorEntry | Validator<string>\n  >;\n\n  @Watch('validator')\n  validateValidator() {\n    this._validator = getValidator(this.validator);\n  }\n\n  /**\n   * Set event to call validator\n   */\n  @Prop({ mutable: true }) validateOn: 'blur' | 'submit' | 'other' = 'blur';\n\n  /**\n     * Read-only property of the checkboxes, returns a ValidityState object that represents the validity states this element is in.\n     */\n  @Prop()\n  get validity() {\n    return this.internals.validity;\n  }\n\n  /**\n   * Set additional HTML attributes not available in component properties\n   */\n  @State() inheritedAttributes: Object = {};\n\n  /**\n   * Specifies if the checkbox is invalid.\n   */\n  @State() hasError: boolean;\n\n  @Watch('hasError')\n  validateHasError() {\n    if (this.disabled) {\n      this.hasError = false;\n    }\n  }\n\n  /**\n   * Language of rendered component\n   */\n  @State() lang: string;\n\n  /**\n   * State to track validation on properties\n   * Contains a list of properties that have an error associated with them\n   */\n  @State() errors: Array<string> = [];\n\n  /**\n   * Events\n   */\n\n  /**\n   * Emitted when the checkbox has been clicked.\n   */\n  @Event() gcdsClick!: EventEmitter<void>;\n\n  /**\n   * Emitted when the checkbox has focus.\n   */\n  @Event() gcdsFocus!: EventEmitter<void>;\n\n  /**\n   * Emitted when the checkbox loses focus.\n   */\n  @Event() gcdsBlur!: EventEmitter<void>;\n\n  private onBlurValidate = () => {\n    if (this.validateOn == 'blur') {\n      this.validate();\n    }\n\n    this.gcdsBlur.emit();\n  };\n\n  /**\n   * Emitted when a checkbox has been inputted. Contains the new value in the event detail.\n   */\n  @Event() gcdsInput: EventEmitter<string[]>;\n\n  /**\n   * Emitted when a checkbox has been changed. Contains the new value in the event detail.\n   */\n  @Event() gcdsChange: EventEmitter<string[]>;\n\n  /**\n   * Emitted when the checkbox has a validation error.\n   */\n  @Event() gcdsError!: EventEmitter<object>;\n\n  /**\n   * Emitted when the checkbox has a validation error.\n   */\n  @Event() gcdsValid!: EventEmitter<object>;\n\n  /**\n   * Call any active validators\n   */\n  @Method()\n  async validate() {\n    handleValidationResult(\n      this.el as HTMLGcdsCheckboxesElement,\n      this._validator.validate(this.value),\n      this.isGroup ? this.legend : this.optionsArr[0].label,\n      this.gcdsError,\n      this.gcdsValid,\n      this.lang,\n    );\n\n    this.checkboxTitle = this.errorMessage;\n  }\n\n  /*\n   * FormData listener to append values like native checkboxes\n   */\n  @Listen('formdata', { target: 'document' })\n  formdataListener(e) {\n    const data = e.formData;\n\n    (this.value as string[]).forEach(value => {\n      // Set formdata for first entry to remove array\n      if ((this.value as string[]).indexOf(value) === 0) {\n        data.set(this.name, value);\n      } else {\n        data.append(this.name, value);\n      }\n    });\n  }\n\n  // Submit validation handler\n  @Listen('submit', { target: 'document' })\n  submitListener(e) {\n    if (e.target == this.el.closest('form')) {\n      if (this.validateOn && this.validateOn != 'other') {\n        this.validate();\n      }\n\n      if (this.hasError && this.validateOn != 'other') {\n        e.preventDefault();\n      }\n    }\n  }\n\n  /*\n   * Form internal functions\n   */\n  formResetCallback() {\n    if (this.value != this.initialState) {\n      this.value = this.initialState;\n    }\n  }\n\n  formStateRestoreCallback(state) {\n    this.internals.setFormValue(state);\n    this.value = [...state.split(',')];\n  }\n\n  /**\n   * Check the validity of gcds-checkboxes\n   */\n  @Method()\n  public async checkValidity(): Promise<boolean> {\n    return this.internals.checkValidity();\n  }\n\n  /**\n   * Get validationMessage of gcds-checkboxes\n   */\n  @Method()\n  public async getValidationMessage(): Promise<string> {\n    return this.internals.validationMessage;\n  }\n\n  /**\n   * Update gcds-checkboxes's validity using internal input\n   */\n  private updateValidity() {\n    if (this.shadowElement?.length > 0) {\n      const validity = validateRadioCheckboxGroup(this.shadowElement);\n\n      let validationMessage = null;\n\n      if (validity?.valueMissing) {\n        validationMessage = this.lang === 'en' ? 'Choose an option to continue.' : 'Choisissez une option pour continuer.';\n      }\n\n      this.internals.setValidity(\n        validity,\n        validationMessage,\n        this.shadowElement[0],\n      );\n\n      // Set input title when HTML error occruring\n      this.checkboxTitle = validationMessage;\n    }\n  }\n\n  /*\n   * Observe lang attribute change\n   */\n  @Watch('lang')\n  watchLang(newValue, oldValue) {\n    if (newValue !== oldValue) {\n      this.lang = newValue;\n    }\n  }\n\n  /*\n   * Validate required properties\n   */\n  private validateRequiredProps() {\n    this.validateOptions();\n    this.validateValue(this.value);\n    this.validateLegend();\n    this.validateName();\n\n    return isValid(this.errors, ['name', 'legend', 'options']);\n  }\n\n  async componentWillLoad() {\n    // Define lang attribute\n    this.lang = assignLanguage(this.el);\n\n    const valid = this.validateRequiredProps();\n\n    this.validateDisabledCheckbox();\n    this.validateHasError();\n    this.validateErrorMessage();\n\n    // Assign required validator if needed\n    requiredValidator(\n      this.el,\n      this.isGroup ? 'checkboxGroup' : 'checkboxSingle',\n    );\n\n    this.validateValidator();\n\n    // Assign checkbox hint to component hint if not group\n    if (\n      !this.isGroup &&\n      this.optionsArr &&\n      this.optionsArr[0]?.hint &&\n      !this.hint\n    ) {\n      this.hint = this.optionsArr[0].hint;\n    }\n\n    if (!valid) {\n      logError('gcds-checkboxes', this.errors);\n    }\n\n    this.initialState = this.value;\n  }\n\n  async componentDidUpdate() {\n    // Validate props again if changed after render\n    const valid = this.validateRequiredProps();\n\n    if (!valid) {\n      logError('gcds-checkboxes', this.errors);\n    }\n  }\n\n  async componentDidLoad() {\n    this.updateValidity();\n\n    // Logic to enable autofocus\n    if (this.autofocus) {\n      requestAnimationFrame(() => {\n        this.shadowElement[0].focus();\n      });\n    }\n  }\n\n  // Handle input and change events\n  private handleInput = (e, customEvent) => {\n    const isInputEvent = e.type === 'input';\n    if (isInputEvent) {\n      const target = e.target as HTMLInputElement;\n      if (target.checked) {\n        this.value = [...(this.value as Array<string>), target.value];\n      } else {\n        // Modify options to prevent re-adding prechecked values when user unchecks\n        this.options = (\n          typeof this.options === 'string'\n            ? JSON.parse(this.options as string)\n            : (this.options as CheckboxObject[])\n        ).map(check =>\n          check.value === target.value ? { ...check, checked: false } : check,\n        );\n\n        // Remove item from value array when unchecked\n        this.value = (this.value as Array<string>).filter(\n          item => item !== target.value,\n        );\n      }\n\n      // Keep form-associated value in sync\n      if ((this.value as string[]).length > 0) {\n        this.internals.setFormValue(this.value.toString());\n      } else {\n        this.internals.setFormValue(null);\n      }\n\n      this.updateValidity();\n    }\n\n    customEvent.emit([...(this.value as string[])]);\n  };\n\n  /*\n   * Validate passed options and assign optionsArr if proper formatting\n   */\n  private assignOptionsArray() {\n    let invalidOptions = false;\n\n    if (Array.isArray(this.options)) {\n      this.optionsArr = this.options;\n    } else if (typeof this.options === 'string' && this.options.trim() !== '') {\n      try {\n        // Assign to random variable to not restart options validation\n        const optionsCheck = JSON.parse(this.options as string);\n\n        if (Array.isArray(optionsCheck)) {\n          this.optionsArr = optionsCheck;\n        } else {\n          this.optionsArr = null;\n          invalidOptions = true;\n        }\n      } catch (e) {\n        logError('gcds-checkboxes', ['Invalid JSON string for options']);\n        this.options = null;\n        invalidOptions = true;\n      }\n    }\n\n    return invalidOptions;\n  }\n\n  render() {\n    const { legend, required, hint, errorMessage } = this;\n\n    const fieldsetAttrs = {\n      'tabindex': '-1',\n      'aria-labelledby': 'checkboxes-legend',\n    };\n\n    if (hint) {\n      const hintID = this.hint ? `checkboxes-hint ` : '';\n      fieldsetAttrs['aria-labelledby'] =\n        `${fieldsetAttrs['aria-labelledby']} ${hintID}`.trim();\n    }\n\n    this.shadowElement = [];\n\n    if (this.validateRequiredProps()) {\n      return (\n        <Host onBlur={() => this.isGroup && this.onBlurValidate()}>\n          {this.isGroup ? (\n            <fieldset class=\"gcds-checkboxes__fieldset\" {...fieldsetAttrs}>\n              <legend id=\"checkboxes-legend\" class=\"gcds-checkboxes__legend\">\n                {this.hideLegend ? (\n                  <gcds-sr-only tag=\"span\">\n                    {legend}\n                    {required && <span class=\"legend__required\">{i18n[this.lang].required}</span>}\n                  </gcds-sr-only>\n                ) : (\n                  <Fragment>\n                    {legend}\n                    {required && <span class=\"legend__required\">{i18n[this.lang].required}</span>}\n                  </Fragment>\n                )}\n              </legend>\n              {hint ? (\n                <gcds-hint id=\"checkboxes-hint\" hint-id=\"checkboxes\">\n                  {hint}\n                </gcds-hint>\n              ) : null}\n\n              {errorMessage ? (\n                <div>\n                  <gcds-error-message\n                    id=\"checkboxes-error\"\n                    messageId=\"checkboxes\"\n                  >\n                    {errorMessage}\n                  </gcds-error-message>\n                </div>\n              ) : null}\n\n              {this.optionsArr &&\n                this.optionsArr.map(checkbox => {\n                  return renderCheckbox(\n                    checkbox,\n                    this,\n                    emitEvent,\n                    this.handleInput\n                  );\n                })}\n            </fieldset>\n          ) : (\n            this.optionsArr &&\n            this.optionsArr.length > 0 &&\n            renderCheckbox(\n              this.optionsArr[0],\n              this,\n              emitEvent,\n              this.handleInput\n            )\n          )}\n        </Host>\n      );\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]}